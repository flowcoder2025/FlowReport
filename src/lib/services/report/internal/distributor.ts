/**
 * Report Distributor
 *
 * 리포트 배포 (이메일/슬랙)
 */
import { prisma } from '@/lib/db'
import { sendReportEmail, type EmailRecipient } from '@/lib/email'
import type { ReportPeriod } from '@prisma/client'
import type { DistributionResult } from '../types'

/**
 * 리포트 배포 실행
 */
export async function distributeReport(
  reportId: string,
  scheduleId: string,
  workspaceName: string,
  periodType: ReportPeriod,
  periodLabel: string,
  pdfBuffer: Buffer
): Promise<DistributionResult> {
  const errors: string[] = []
  let emailsSent = 0
  let slackSent = false

  // 스케줄 정보 조회
  const schedule = await prisma.reportSchedule.findUnique({
    where: { id: scheduleId },
    include: {
      recipients: {
        where: { isActive: true },
      },
    },
  })

  if (!schedule) {
    return { emailsSent: 0, slackSent: false, errors: ['Schedule not found'] }
  }

  // 상태 업데이트: SENDING
  await prisma.generatedReport.update({
    where: { id: reportId },
    data: { status: 'SENDING' },
  })

  // 이메일 발송
  if (schedule.emailEnabled && schedule.recipients.length > 0) {
    try {
      const recipients: EmailRecipient[] = schedule.recipients.map((r) => ({
        email: r.email,
        name: r.name || undefined,
      }))

      const emailResult = await sendReportEmail({
        recipients,
        subject: `[FlowReport] ${workspaceName} - ${periodLabel} ${periodType === 'WEEKLY' ? '주간' : '월간'} 리포트`,
        workspaceName,
        periodType,
        periodLabel,
        pdfBuffer,
      })

      emailsSent = emailResult.totalSent

      if (emailResult.totalFailed > 0) {
        const failedEmails = emailResult.results
          .filter((r) => !r.success)
          .map((r) => r.error)
          .filter(Boolean)
        errors.push(...failedEmails.map((e) => `Email: ${e}`))
      }
    } catch (error) {
      errors.push(`Email send failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  // 슬랙 발송
  if (schedule.slackEnabled && schedule.slackWebhook) {
    try {
      slackSent = await sendSlackNotification(
        schedule.slackWebhook,
        workspaceName,
        periodType,
        periodLabel
      )
      if (!slackSent) {
        errors.push('Slack notification failed')
      }
    } catch (error) {
      errors.push(`Slack failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  // 최종 상태 업데이트
  const finalStatus = errors.length === 0 ? 'COMPLETED' : (emailsSent > 0 || slackSent ? 'COMPLETED' : 'FAILED')

  await prisma.generatedReport.update({
    where: { id: reportId },
    data: {
      status: finalStatus,
      emailsSent,
      slackSent,
      completedAt: new Date(),
      error: errors.length > 0 ? errors.join('; ') : null,
    },
  })

  return { emailsSent, slackSent, errors }
}

/**
 * 테스트 이메일 발송 (단일 수신자)
 */
export async function sendTestEmail(
  email: string,
  workspaceName: string,
  periodType: ReportPeriod,
  pdfBuffer: Buffer
): Promise<{ success: boolean; error?: string }> {
  try {
    const periodLabel = periodType === 'WEEKLY' ? '테스트 주간' : '테스트 월간'

    const result = await sendReportEmail({
      recipients: [{ email }],
      subject: `[FlowReport 테스트] ${workspaceName} - ${periodLabel} 리포트`,
      workspaceName,
      periodType,
      periodLabel,
      pdfBuffer,
    })

    if (result.totalSent > 0) {
      return { success: true }
    }

    return {
      success: false,
      error: result.results[0]?.error || 'Failed to send email',
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * 슬랙 웹훅으로 알림 발송
 */
async function sendSlackNotification(
  webhookUrl: string,
  workspaceName: string,
  periodType: ReportPeriod,
  periodLabel: string
): Promise<boolean> {
  try {
    const periodTypeLabel = periodType === 'WEEKLY' ? '주간' : '월간'

    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: `${workspaceName} ${periodTypeLabel} 리포트`,
              emoji: true,
            },
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*${periodLabel}* ${periodTypeLabel} 리포트가 생성되었습니다.\n\n이메일로 발송된 PDF 리포트를 확인해주세요.`,
            },
          },
          {
            type: 'context',
            elements: [
              {
                type: 'mrkdwn',
                text: `_Generated by FlowReport at ${new Date().toLocaleString('ko-KR')}_`,
              },
            ],
          },
        ],
      }),
    })

    return response.ok
  } catch {
    return false
  }
}
